<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Object oriented programming with Bee.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, bee, syntax, class, object, programming">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Website title -->
  <title>Bee Objects</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Bee Highlighter -->
  <script src="bee.js"></script>
  <!-- Sage-Code CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="bee_render()">
<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>

<h1>Bee Objects</h1>
<div class="alert alert-secondary shadow-sm">
Bee is implementing object oriented principles: abstraction, encapsulation, inheritance and polimorphism. Objects are data structured defined by the user. 
</div>

<p>An Object is the root of all other object types. An root Object has onlye methods, but no attributes. An object can have associated several public methods and a companion. You can use dot notation to access object members.</p>

<div align="center">
  <img src="img/method-call.svg" alt="method call"
  width="420" class="img-fluid protect rounded shadow border" >
  <p>Method Call</p>
</div>

<h2>Instantiation</h2>

<p>An object can be instantiated using reserved keyword "new" that is a declaration. The type Object has a default companion that is implemented in language core and is named: Object(). You can use this companion to create an object instance.</p>

<pre><code class="language-bee">** empty object
new object := Object(); 

** set attribute values
new object["a1"] := 1;
new object["a2"] := 2;

** check the object
expect object == {"a1":1, "a2":2};

** remove attributes
del object["a1"];
del object["a2"];

** check the object
expect object == {};
</code></pre>

<h3>Define attributes</h3>

<p>An object can have attributes, declared with a JSON like syntax. In this case the type do not have methods other then the default methods.</p>

<pre><code class="language-bee">
type TName {attribute Type, ...} <: Object:
</code></pre>

<h3>Define methods</h3>

<p>An object can be declared with a block of code. In this case the block of code start with ":" and is ending with one of these keywords: static, dynamic, abstract;</p>

<h4>Syntax Pattern</h4>

<pre><code class="language-bee">** define an object type
type TName {attribute Type, ...} <: Object[+(Trait,....)]:
  ** define internal states 
  new name &isin; Type;

  ** define private method
  rule name(self &isin; TName):
    ...
  return;
  
  ** define dynamic method
  rule .name(self &isin; TName):
    ...
  return;
[static | dynamic | abstract];
</code></pre>

<ul> 
   <li>static   = it has a static scope, can't be instantiated</li>  
   <li>dynamic  = has a dynamic scope, can be instantiated</li>
   <li>abstract = can be extended but not instantiated</li> 
</ul>

<h3>Example</h3>

<p>A custom object type that has two attributes and one public method. The object is instantiated using the default companion, that is generated by the compiler automaticly. The .log() method is called using "apply" and dot notation.</p>

<pre><code class="language-bee">** define Foo as object:
type Foo: {a, b &isin; N} &lt;: Object:
    ** define method: log
    rule .log(self &isin; Foo):
        print "a =" + self.a;
        print "b =" + self.b;
    return;
dynamic;

** test Foo in the main rule
rule main:
    ** create an instance of Foo
    new test := Foo(a:1,b:2);

    ** call a method test.log
    apply test.log;

    ** verify attribute values
    fail if test.a &ne; 1; 
    fail if test.b &ne; 2; 
return;
</code></pre>

<h4>Expected Output</h4>

<pre class="language-out">
a = 1
b = 2
</pre>

<h3>Companion</h3>

<p>A companion is a special rule that we can define to initialize  instqnces of an object type. An object can have associated one or more companions. Only dynamic types can have companions.</p>

<p>Next example demonstrate a type Foo that has a companion Foo(). This receive two parameters and produce a result of type Foo. The companion once defined is replacing the default compation that is no longer created automaticly by compiler.</p>

<pre><code class="language-bee">** define Foo as object:
type Foo: {a, b &isin; N} &lt;: Object:
    ** define method: log
    rule .log(self &isin; Foo):
        print "a =" + self.a;
        print "b =" + self.b;
    return;
normal;

** define Foo companion
rule Foo(p1,p2 &isin; N) =&gt; (self &isin; Foo):
   ** initialize the object using JSON
   let self := {a:p1, b:p2};
return;

** create new object
rule main:
    ** Create an instance of Foo
    new test := Foo(10,20);

    ** call a method test.log
    apply test.log;
return;
</code></pre>

<h4>Expected Output</h4>

<pre class="language-out">
a = 10
b = 20
</pre>

<h4>Notes:</h4>
<ul>
<li>Types and companions start with capital letters;</li>    
<li>Companion has the same name as the data type;</li>
<li>Companion is returning a reference to the new object;</li>
</ul>

<h4>Variable arguments</h4>

<p>Next example create an object using a companion. This particular companion can receive a variable number of arguments and produce an object that has sum and average of arguments calculated.</p>

<pre><code class="language-bee">** define the object type
type MyObject: {sum &isin; N, avg &isin; R} &lt;: Object;

** define an onject companion
rule MyObject(*v &isin; [N]) => (self &isin; MyObject):
    ** local variables
    new count := 0;
    new x &isin; N;
    for &forall; x &isin; v do
        let self.sum += x; 
        let count += 1;
    repeat;
    self.avg = self.sum / count;
return;
</code></pre>

<h2>Key Looping</h2>

<p>Bee objects are based on dictionaries. In fact an object do not have attributes it has keys. Each attribute is a (key:value) pair. Keys are of type string. You can append new attributes by creating new (key:value) pairs in the object companion.</p>

<p>If you define the type upfront, Bee can loop the keys and you can set-up value for each attribute in a loop. This is one of scenarios where you can use the "new" statement in a loop.</p>

<pre><code class="language-bee">** define object type
type MyObject: {a1,a2,a3 &isin; R} <: Object

** define a companion rule
rule MyObject(*values &isin; R) => (self &isin; MyObject):
    ** set attribute values in a loop
    new i := 0;
    for &forall; key &isin; MyObject.keys() do
        new self[key] := values(i);
        let i += 1;
    done;
return;
</code></pre>

<h3>Static objects</h3>

<p>By default object context is dynamic. When a new object is created, new memory is alocated. Sometimes we need to define a static context. A type that is declared static can't be instantiated. Static types are singleton objects. </p>

<h4>Example:</h4>

<pre><code class="language-bee">** define Foo as object with 2 public attributes:
type Foo: {start = 0, step = 1 &isin; N} &lt;: Object:
    ** internal state
    new count := 0;

    ** public method
    rule .next(p &isin; N) => (r &isin; Z):
       if start > count do
          let count := start;
       else 
          let count += step;
       endif;
       let r := count;
    return;
static;

rule main:
    ** set singleton states
    let Foo start := 10; 
    let Foo step  := 5;
    cycle:
       new x := 0;
    while x < 30 do
       let x := Foo.next();
       print "x = " + x; 
    done;
return;
</code></pre>

<h4>Expected Output:</h4>

<pre class="language-out">
x = 10
x = 15
x = 20
x = 25
x = 30
</pre>

<h4>Notes:&nbsp;</h4>

<ol>
<li>Usually the attributes have default values; </li>
<li>Static methods do not receive attribute: self;</li>
<li>Local variables are private and static;</li>
</ol>

<h2>OOP Features</h2>

<p>The root object type is called: Object, synonim O. When you create an array of objects you can use notation: [O]. We use "O" in collections declarations despite that O looks like 0 zero.</p>

<h3>Encapsulation</h3>

<p>Type declaration and its companion must be defined in the same module. All methods of a single type are defined inside a companion rule. One module can contain multiple types.</p>

<h4>Public members</h4>

<p>Access to members is enable by using (.) prefix and dot notation. All public members must start with a dot. If a type is public, it must start with dot and the constructor also must start with a dot.</p>

<h4>Private members</h4>

<p>Private members can be static or dynamic. By default, members are private & static. Dynamic members must be prefix using qualifier "self." that is the current object or a static singleton that represents the companion context.</p>

<h3>Inheritance</h3>

<p>Inheritance symbol in Bee is "<:" that is used to define the super-type. A derived type companion must call the super companion using qualifier: "super."</p>

<h4>Examples:</h4>   

<pre><code class="language-bee">** define Foo type
type Foo: {a, b &isin; N} &lt;: Object;

** define Bar subtype of Foo
type Bar: {r &isin; R} &lt;: Foo;

** define new companion
rule Bar(p1, p2 &isin; N, p3 &isin; R) => (self  &isin; Bar):
   let self := Foo(p1, p2);
   let self.r := p3;

   ** overvrite the original method
   rule .log():
      apply super.log;  -- call the inherited method
      print "r = " + r; -- output the new property
   return;
return;
</code></pre>

<h3>Abstraction</h3>

<p>Bee can define abstract companions. These can contain default methods and forward declarations. That are method signatures that have no implementation.</p>

<h4>Example</h4>

<p>Next example demonstrate how to create a companion that behave like an abstract type. This declaration do not use the parameters and have no implementation for .log() method.</p>

<pre><code class="language-bee">
** define typles companion
rule Root(p1, p2 &isin; N) => (self &isin; Object):

   ** define an empty method log()
   rule .log();
return;

** use an abstract type
Type Foo <: Root;
rule Foo(p1, p2 &isin; N) => (self &isin; Foo):

   ** imlement the log method
   rule .log():
      for x &isin; self.keys() do
          print x + " = " + self[x]; 
      done;
   return;
return;
</code></pre>

<h3>Traits</h3>

<p>A trait is a special structure that encapsulate behaviour. Traits can be used to extend a specific type. Think of traits like auguments that you can attach to an object type.</p>

<h4>Declaration</h4>

<p>An object, can be augmented using traits in the declaration. The trits are specified using symbol + follow by a comma separated list of traits. The traits can be local or imported from other module.</p>

<pre><code class="language-bee">
type TName {attribute Type, ...} <: Object+(trait_list):
</code></pre>

<h4>Example</h4>

<p>In next example we define a trait named: Extra, this is used to define type Foo that is augmented with Extra. You can call the .log() method like it belong to Foo but is defined inside trait.</p>

<pre><code class="language-bee">
** define new trait
trait Extra(self &isin; Object):
   ** overvrite the log method
   rule .log():
      for x &isin; self.keys() do
          print x + " = " + self[x]; 
      done;
   return;
return;

** use trait Extra to define Foo
type Foo: {a, b &isin; N} &lt;: Object+Extra;

rule main:
   new foo = Foo(a:1, b:2);
   foo.log;
return;
</code></pre>

<h4>Expected Output</h4>

<pre class="language-out">
a = 10
b = 20
</pre>

<p><b>Read next:</b>
<a href="collections.html">Collections</a></p>
<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>