<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Object oriented programming with Bee.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, bee, syntax, class, object, programming">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Website title -->
  <title>Bee Objects</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Bee Highlighter -->
  <script src="bee.js"></script>
  <!-- Sage-Code CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="bee_render()">
<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>
<h1>Bee Objects</h1>
<div class="alert alert-secondary shadow-sm">
Bee is using a type declaration to define object attributes. Later you can define one constructor and associated methods. Objects can be extended using inheritance model and methods can be overvriten.
</div>

<h2>Features</h2>

<p>Bee is implementing object oriented principles: abstraction, encapsulation, inheritance and polimorphism. However Bee do not have classes. Objects are instances of composite data types, similar to structs or records used in other languages.</p>

<h4>Example:</h4>

<p>Next example demonstrate a type Foo that has one public method ".bar" and one constructor: Foo(). The constructor is an anonymous rule that receive two parameters and produce a result of type Foo.</p>

<pre><code class="language-bee">** define Foo as object:
type Foo: {a, b &isin; N} &lt;: Object;

**define Foo constructor:
rule Foo(p1,p2 &isin; N) =&gt; (self &isin; Foo):
    let self := {a:p1, b:p2};
return;

** define method: Foo.bar
rule .bar(self &isin; Foo):
    print "a =" + self.a;
    print "b =" + self.b;
return;

** create new object using constructor
rule main:
    ** call constructor to create an instance of Foo
    new test := Foo(1,1);

    ** call a method test.bar
    test.bar();
    fail if test.a &ne; 1; -- verify attribute a
    fail if test.b &ne; 1; -- verify attribute b
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Types are defined with capital letters;</li>
<li>Constructor has the same name as the data type;</li>
<li>Constructor is returning a reference to the new object;</li>
<li>You create a new object instance using the keyword "new";</li>
<li>Methods are public and must use dot (.)) prefix;</li>
</ul>

<div align="center">
  <img src="img/method-call.svg" alt="method call"
  width="420" class="img-fluid protect rounded shadow border" >
  <p>Method Call</p>
</div>

<h3><a id="rule-as-closure"></a>Constructor</h3>

<p>The Object is the most simple type and is the root type for all objects. An Object can be created using the default constructor but you can define a new constructor. The new constructor can have local variables and rules.</p>

<h4>Example:</h4>

<p>Next example is typical, to create a symple object using a constructor. This constructor receive a variable number of arguments and produce an object that has sum of arguments and the average.</p>

<pre><code class="language-bee">** define the object type
type MyObject: {sum &isin; N, avg &isin; R} &lt;: Object;

** define an onject constructor with varargs
rule MyObject(*v &isin; [N]) => (self &isin; MyObject):
    ** local variable
    new count := 0;
    new x &isin; N;
    for &forall; x &isin; v do
        let self.sum += x; 
        let count += 1;
    repeat;
    self.avg = self.sum / count;
return;
</code></pre>

<h3><a id="rule-as-singleton"/>Object Initialization</h3>

<p>An object type can be initialized empty. The attributes can be assigned later. But of course, you can use a JSON notation that we already demonstrated. Also, the object can be created using a collection builder that we will study later.</p>

<pre><code class="language-bee">** empty object
new object := {}; 

** set attribute values
new object.attr1 := value1;
new object.attr2 := value2;
...
</code></pre>

<p>An equivalent syntax is using attribute value to identify the attribute names. This notation is typicaly used with integer variables but in Bee you can use this notation with strings or symbols.</p>

<pre><code class="language-bee">** empty object
new object := {}; 

** set attribute values
new object["attr1"] := value1;
new object["attr2"] := value2;
...
</code></pre>

<h2><a id="rule-as-singleton"/>Key Looping</h2>

<p>Bee objects are based on dictionaries. In fact an object do not has attributes it has keys. Each attribute is represented by a key. Keys are iterable of type string.</p>

<p>If you define the type upfront, Bee can loop the keys and you can set-up value for each attribute in a loop. This is one of scenarios where you can use the "new" statement in a loop.</p>

<pre><code class="language-bee">** define object type
type MyObject: {a1,a2,a3 &isin; R} <: Object

** define a constructor
rule MyObject(*values &isin; R) => (self &isin; MyObject):
    ** set attribute values in a loop
    new i := 0;
    for &forall; key &isin; MyObject.keys() do
        new self[key] := values(i);
        let i += 1;
    done;
return;
</code></pre>

<p><b>Read next:</b>
<a href="collections.html">Collections</a></p>
<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>