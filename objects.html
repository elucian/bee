<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Object oriented programming with Bee.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, bee, syntax, class, object, programming">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Website title -->
  <title>Bee Objects</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Bee Highlighter -->
  <script src="bee.js"></script>
  <!-- Sage-Code CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="bee_render()">
<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>
<h1>Bee Objects</h1>
<div class="alert alert-secondary shadow-sm">
Bee is a esoteric and experimental programming language design by Sage-Code.
</div>
<!-- work in progress-->
<hr>

<h3><a id="rule-as-closure"></a>Rule as closure</h3>
<p>A rule that have nested rules can be called  <em> "closure"</em>. This is actually a rule behaving like an object. Such a rule is a dirty rule. It can not be used in expressions, but it can produce a result. The result can be captured into a variable using assign statements.</p>

<h4>Properties:</h4>
<ul>
<li>A closure can have output parameters,</li>
<li>A closure can have side-effects,</li>
<li>A closure can modify shared variables,</li>
<li>A closure can create a result,</li>
<li>A closure can generate a rule.</li>
</ul>

<h4>Pattern:</h4>

<p>Next pattern is typical, for a closure to create a rule. The enclosed rule becomes public but not by using a dot prefix but is transfer as the result of the closure. Observe that object_rule is not follow by round brackets "()" therefore it's reference is assigned.</p>

<pre><code class="language-bee">** Define a closure:
** define object companion
rule closureName(param &isin; type...) => (result &isin; Rule):
    ** context variable
    context_variable := value;
    ...
    ** create enclosed rule
    rule object_rule(param &isin; type,...):
        ...
        context_variable := expression(param);
    return;
    ** assign a rule reference to result
    result := object_rule;
return;
</code></pre>

<h3><a id="rule-as-singleton"/>Rule as singleton</h3>

<p>A rule that behave as an object is called singleton. You can use this kind of rule as object that have a single instance. These rules can not be instantiated but one single instance is automatically created when the module is loaded.</p>

<div align="center">
  <img src="img/singleton-rule.svg" alt="singleton rule"
  width="420" class="img-fluid protect rounded shadow border" >
  <p>Singleton Anatomy</p>
</div>


<h4>Properties:</h4>
<ul>
<li>A singleton name start with uppercase letter,</li>
<li>A singleton do not have parameters nor result,</li>
<li>A singleton can not be instantiated, or cloned,</li>
<li>Singleton members starting with "." are public members,
<li>Singleton members that do not have prefix are private members.</li>
</ul>

<h4>Pattern:</h4>

<pre><code class="language-bee"># Define a singleton object:
object SgtName:
    ** singleton, public constant (uppercase)
    .CST := value;
    ...
    ** singleton, public property
    .public_property := "value";
    ...
    ** singleton, private property
    private_property := "value";
    ...
    ** singleton public rule
    rule .public_rule(param &isin; type,...) =&gt; (result &isin; type):
        ...
        result := expression;
    return;
    ...
    ** singleton private rule
    rule private_rule(param &isin; type,...) =&gt; (result &isin; type):
        ...
        result := expression;
    return;
    ...
end SgtName;

# Using singleton properties and methods
rule main:
  ** call a singleton rule
  r := SgtName.singleton_rule(argument, ...);

  ** check singleton public property
  print r.public_property; -- expect "value"
return;
</code></pre>

<h3><a id="rule-as-companion"></a>Rule as companion</h3>

<p>A <em>companion</em> is a special rule that extend an object. There can be only one companion for an object. The companion has role of a container that encapsulate object methods and optional, an object constructor.</p>

<div align="center">
  <img src="img/companion-rule.svg" alt="companion rule"
  width="420" class="img-fluid protect rounded shadow border" >
  <p>Companion Anatomy</p>
</div>

<h4>Properties:</h4>
<ul>
<li>A companion has same name as its associated object,</li>
<li>A companion can have public and private methods,</li>
<li>Constructors are anonymous rules that return an object,</li>
<li>Members starting with "." are public members,
<li>Members that do not have prefix are private members.</li>
</ul>

<p><b>Node:&nbsp;</b>A companion rule is a singleton associated with one or more objects. A method is bound to an object explicit. That is first parameter is called "self" and it represent an associated object that is transmitted by the call as qualifier:</p>

<div align="center">
  <img src="img/method-call.svg" alt="method call"
  width="420" class="img-fluid protect rounded shadow border" >
  <p>Method Call</p>
</div>

<h4>Pattern:</h4>

<pre><code class="language-bee">** Define a type of Object:
type ObjType: {attribute:type, ...} &lt;: Object;

** Augment object with methods
rule ObjType(param &isin; type,... ) => (self &isin; ObjType) :
    ** use super constructor:
    self = super(params);
    ...
    ** attach traits
    self.attach(trait_name1);
    ...
    ** private method
    rule private_method(self &isin; ObjType, param &isin; type,...) =&gt; (result &isin; type):
       ...
       result := expression;
    return;
    ...
    ** public method
    rule .public_method(self &isin; ObjType, param &isin; type,...) =&gt; (result &isin; type):
       ...
       result := expression;
    return;
    ...
return;

# Using object type and methods
rule main:
    ** create an object instance
    obj := {attribute:value, ...} &isin; ObjType;
    ** execute a plubcli rule
    r := obj.public_rule(argument, ...);
    ** access attributes
    print r.attribute;     -- original attribute
    print r.new_attribute; -- extended attribute
return;
</code></pre>

<h4>Example:</h4>

<p>Next example demonstrate an object Foo that has one public method ".bar" and one constructor: Foo(). The constructor is an anonymous rule that receive two parameters and produce a result of type Foo.</p>

<pre><code class="language-bee">** define Foo as object:
type Foo: {a, b &isin; N} &lt;: Object;

**Implement Foo constructor:
rule Foo(p1,p2 &isin; N) =&gt; (self &isin; Foo):
    self := {a:p1, b:p2};
return;

**Implement Foo companion:
upgrade Foo:
    ** define a method for Foo
    rule .bar(self &isin; Foo):
        print "a =" + self.a;
        print "b =" + self.b;
    return;
continue;

** create new object using constructor
rule main:
    ** call constructor to create an instance of Foo
    test := Foo(1,1);

    ** call a method test.bar
    test.bar;
    fail if test.a &ne; 1; -- verify attribute a
    fail if test.b &ne; 1; -- verify attribute b
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Methods can be overloaded: (multiple signatures);</li>
<li>Methods are identified using multiple dispatch;</li>
<li>Methods can be overwritten in other modules;</li>
<li>Methods can be private or public using underscore/dot prefix;</li>
</ul>

<p><b>Read next:</b>
<a href="collections.html">Collections</a></p>
<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>