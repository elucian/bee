<html><head>
  <meta charset="utf-8">
  <meta name="description" content="Define Bee language rules.">
  <meta name="author" content="Elucian Moise">
  <meta name="keywords" content="sage, code, bee, bee-lang, rules, syntax, paradigm">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Website title -->
  <title>Bee Rules</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <!-- Icon -->
  <link rel="icon" type="image/png"  href="../images/favicon.ico">
  <!-- Bee Highlighter -->
  <script src="bee.js"></script>
  <!-- Sage-Code CSS -->
  <link rel="stylesheet" href="../sage.css">
  </head>
<body onload="bee_render()">
<div class="container">

<!-- header -->
<div class="row">
    <div class="col">
        <a href="https://sagecode.net"><img src="../images/sage-logo.svg" alt="Sage-Code Laboratory" height="80"/></a>
    </div>
    <div class="col  bottom-right">
        <a href="index.html#lang-index" rel="nofollow">index</a>&lt;--
    </div>
</div><hr>

<h1>Bee Rules</h1>
<div class="alert alert-secondary shadow-sm">
Bee is rule oriented language. A rule is a named section of code that can be executed multiple times on demand. Rules can have parameters and can return results, similar to functions and methods, used in other languages.
</div>

<h2>Bookmarks</h2>

<ul>
<li><a href="#rule-anatomy">rule anatomy</a></li>
<li><a href="#rule-features">rule features</a></li>
<li><a href="#rule-purpose">rule purpose</a></li>
<li><a href="#early-termination">early termination</a></li>
<li><a href="#advanced-topics">advanced topics</a></li>
</ul>

<h2><a id="rule-anatomy"/>Rule Anatomy</h2>

<p>A rule declaration start with keyword: "rule" and end with keyword "return". You can send arguments to a rule by using a rule call and you can receive results that can be captures into variables using assign statement.</p>

<div align="center">
  <img src="img/bee-rule.svg" alt="bee rule" width="500" class="img-fluid protect rounded shadow border" >
  <p>Rule Concept</p>
</div>

<p>We have chosen "rule" keyword instead of "def" for naming a sub-routine. So, Bee has "rules" and "functions". Rules are subprograms that can have side-effects similar to procedures, methods or subroutines used in other languages. </p>

<h4>Properties:</h4>
<ul>
<li>A rule is declared with keyword <em> "rule"</em>;</li>
<li>A rule can have local variables and constants;</li>
<li>A rule can have public attributes, and internal states;</li>
<li>A rule can have nested rules that are public or private;</li>
<li>A rule can create another rule that is called closure;</li>
<li>A rule that receive as parameter an object is a method;</li>
<li>A rule that produce an object as a result is a constructor;</li>
<li>A rule that have same name as a composite type is a companion;</li>
</ul>


<h2><a id="rule-features"/>Features</h2>

<p>In Bee the rules are versatile yet comprehensible. Making rules require design skills. To learn this skill you must know understand first thr rule features. Next topic will explain the most important features:</p>

<ul>
<li><a href="#rule-params">rule parameters</a></li>
<li><a href="#rule-results">rule results</a></li>
<li><a href="#variadic-rules">variadic rules</a></li>
</ul>

<h3><a id="rule-params"></a>Rule parameters</h3>

<p>Parameters are special variables defined in rule signature using parenthesis. The parameter list is used to define input variables. Each parameter has a name, a type and initial value.</p>

<h4>Example:</h4>

<p>In next example we define a rule that require two string parameters. We provide arguments for each parameters by position. In this case, foo do not return results so we use "apply" keyword to execute the rule. Second parameter is input/output string so it can be modified.</code>.

<pre><code class="language-bee">** a rule with two parameter
rule foo(name &isin; S, message &isin; [S]):
    let message:= "hello:" + name + ". I am Foo. Nice to meet you!";
return;

** using apply + rule name will execute the rule
rule main:
    new str &isin; S;
    apply foo("Bee", str);
    print str;
return;
</code></pre>

<p><b>Expected output:</b></p>
<pre class="language-bee">hello: Bee. I am Foo. Nice to meet you!</pre>

<h4>Notes:</h4>
<ul>
<li>Parameters are enumerated in a list separated by comma;</li>
<li>Optional parameters are initialized using "=";</li>
<li>Primitive types parameters receive values: <em> by copy</em>;</li>
<li>Composite type parameters receive value: <em> by share</em>;</li>
</ul>

<h3><a id="rule-results"></a>Rule results</h3>

<p>A rule can have multiple results. Result variables must be declared. This is characteristic to Bee language. In other languages, you can use: "return value" but in Bee things are different. A rule has a result list similar to a parameter list.</p>

<h4>Example:</h4>

<p>In this example we have a rule that return a tuple of two values. These values can be assigned inside the rule body. If the values are not assigned the default values are used. Like parameters, the result variables can have initial values.</p>

<pre><code class="language-bee">** rule with two results "s" and "d"
** parameter x is mandatory y is optional
rule com(x &isin; Z, y = 0 &isin; Z) =&gt; (s, d &isin; Z):
    let s := x + y;
    let d := x - y;
return;

rule main:
    ** capture result into a single variable
    new r := com(3,2); -- create a list
    print r; -- (5,1)

    ** deconstruction of result into variables: s, d
    new s, d := com(3,2);    -- capture two values
    print (s, d, sep:",") ;  -- 5,1 (use separator = ",")

    ** ignore second result using variable "_"
    new a, _ := com(3);
    print a; -- 3
return;
</code></pre>

<h4>Notes:</h4>
<ul>
<li>Multiple results are declared with name and can also have initial value;</li>
<li>A rule with multiple results can be called using spread operator (*)</li>
<li>You can capture results into multiple variables separated by comma;</li>
<li>You can ignore one result using anonymous variable "_";</li>
<li>Rules with multiple results can not be used in expressions;</li>
</ul>

<h3><a id="variadic-rules" class="anchor" href="#varargs"></a>Variadic Rule</h3>
<p>The last parameter in a parameter list can use prefix: "*" to receive multiple values into an array of values. This is called "varargs" parameter and is very useful way to accept multiple parameters by declaring just one.</p>

<pre><code class="language-bee"># rule with varargs
rule foo(*bar &isin; [Z]) =&gt; (x &isin; Z):
    new c := bar.count();
    ** precondition
    if (c == 0) do
        let x := 0;
        exit;
    done;
    ** sum all parameters
    for &forall; i &isin; (0.!c) do
        let x += bar[i];
    repeat;
return;
** we can call foo with variable number of arguments
rule main:
    print foo();        -- 0
    print foo(1);       -- 1
    print foo(1,2);     -- 3
    print foo(1,2,3);   -- 6
    print foo(1,2,3,4); -- 10
return;
</code></pre>

<h2><a id="early-termination"/>Early Termination</h2>

<p>A rule should have a single exit point. Therefore in Bee the last statement in a rule is "return". The return is closing the rule block. However a rule can have an one or many other termination points. A function can be interrupted using keyword "exit" that terminate the rule without signaling any error. Other way to terminate a rule is to create an exception. This will be explained later.</p>

<h4>Pattern:</h4>
<pre><code class="language-bee">** define a functional rule
rule name(param &isin; type,...) =&gt; result &isin; type:
    ...
    exit if condition; -- early (successful) transfer
    ...
    let result := expression; -- computing the result
    ...
return;

rule main:
    ** direct call and print the result
    print rule_name(argument,...);

    ** capture rule result into a new variable:
    new r := rule_name(argument,...);

    ** using existing variable:
    new n &isin; type;
    let n := rule_name(argument,...)
return;
</code></pre>

<h2><a id="advanced-topics"/>Advanced Topics</h2>

<p>Next extra features about functions will be explained later in future articles. Making examples for these features require knowledge about collections and data processing. So you can read a brief introduction now then skip ahead.</p>

<ul>
<li><a href="#static-members">static members</a></li>
<li><a href="#forward-declarations">forward declarations</a></li>
<li><a href="#recursive-rules">recursive rules</a></li>
<li><a href="#multi-threading">multi threading</a></li>
<li><a href="#external-rules">external rules</a></li>
<li><a href="#purity-level">purity level</a></li>
</ul>

<h3><a id="static-members"/>Static members</h3>

<p>Companion properties are static. There is no need and not possible to define a singleton and a companion with the same name. A companion is already a singleton, You can access companion rules and attributes using dot notation with the object name or with the companion name.</p>

<h4>Restrictions:</h4>

<ol>
<li>You can't access companion attributes from singleton rules,</li>
<li>You can't access companion methods from a singleton rules.</li>
</ol>
<h4>Example:</h4>

<pre><code class="language-bee">** define Foo as object with 2 public attributes:
type Foo: {a, b &isin; N} &lt;: Object;

** define constructor with same name as the type name
rule Foo(p1, p2 &isin; N) => (self &isin; Foo):
    ** define static property
    new x &isin; N;

    ** create the object using parameters
    self   := {a:p1, b:p2}; -- create object instance
    self.c := x;            -- create a new attribute

    ** define static methods
    rule .set_x(p &isin; N):
       let x := p;
    return;

    ** define a object method
    rule .bar(self &isin; Foo):
        print "a  =" + self.a;
        print "b  =" + self.b;
        print "c  =" + self.c;
    return;
return;

** run bar() rule using object test as dot qualifier
rule main:
    ** modify singleton state: x = 3
    apply Foo.set_x(3);
    ** call constructor to create an instance of Foo
    new test := Foo(1,2);
    ** call a method using apply (print private attributes)
    apply test.bar;
return;
</code></pre>

<h4>Expected Output:</h4>

<pre class="language-out">
a  = 1
b  = 2
c  = 3
</pre>

<p><b>Note:&nbsp;</b>Property "c" is display as if belong to the object. This is because the constructor has created a new attribute. In real life, you can use this trick to create new properties to an existing object without modification of original object structure.</p>


<h3><a id="forward-declarations"></a>Forward declarations</h3>

<p>Hoisting is a technique used by many modern compilers to identify declarations of members. Using this technique you can use an identifier before it is defined. In Bee there is no hoisting technique. You can not use an identifier before it is declared or loaded.</p>

<p>To be able to create a faster compiler we use a retro design. In Bee the main() rule is defined at the bottom of the main module. Private rules must be defined first. Public rules are defined last in the module. </p>

<p>Two rules may call each other and create a cyclic interdependence. For this special case you can declare a rule "signature" before implementing it. That is called "forward declaration". Most modules do not need forward declarations.</p>

<h4>Pattern:</h4>

<pre><code class="language-bee">** forward declaration pattern
rule plus(Z,Z) &isin; Z; -- forward declaration

** declare the main rule
rule main:
   ** execute before implementation
   print plus(1,1);
return

** later implement the rule "plus"
rule plus(a,b &isin; Z) =&gt; (r &isin; Z):
  let r := (a + b);
return;
</code></pre>

<h3><a id="recursive-rules"/>Recursive Rules</h3>

<div class="alert alert-secondary">A rule that call itself is so called "recursive". You should know any recursive rule can be replaced by a stack and a cycle that is much more efficient than a recursive rule.</div>


<h4>Example1</h4>

<p>Regular recursive rule can not be optimized by the compiler.</p>

<pre><code class="language-bee">** this rule is not optimized:
rule fact(n &isin; N) =&gt; (r &isin; N):
    when (n = 0) do
        let r := 1;
    else
        let r := n &middot; fact(n-1);
    done;
return;
</code></pre>

<h4>Tail Call Optimization</h4>

<div class="alert alert-secondary">TCO apply to a special case of recursion. The gist of it is, if the last thing you do in a function is call itself (e.g. it is calling itself from the "tail" position), this can be optimized by the compiler to act like iteration instead of standard recursion.</div>

<p>Normally during recursion, the runtime needs to keep track of all the recursive calls, so that when one returns it can resume at the previous call and so on. Keeping track of all the calls takes up space, which gets significant when the function calls itself a lot. But with TCO, it can just say "go back to the beginning, only this time change the parameter values to these new ones." It can do that because nothing after the recursive call refers to those values.</p>

<h4>Example2</h4>

<p>Compiler should be able to optimize this recursive rule.</p>

<pre><code class="language-bee">** this rule can be optimized:
rule tail(n &isin; N, acc &isin; N) =&gt; (r &isin; N):
    when (n = 0) do
      let r:= acc;
    else
      let r:= tail(n-1, acc &middot; n);
    done;
return;

rule fact(n &isin; N) =&gt; (r &isin; N):
  let r := tail(n , 1);
return;
</code></pre>

<h4>Example3</h4>

<p>Replacing a recursive rule with a cycle is more difficult but rule may run faster:</p>

<pre><code class="language-bee">** this rule is manually optimized:
rule fact(a &isin; N, b &isin; N) =&gt; (r &isin; N):
    while (b &gt; 1) do
      let a := a &middot; a + a;
      let b := b - 1;
    else
      let r := a;
    repeat;
return;</code></pre>

<h3><a id="external-rules"></a>External rules</h3>
<p>Will be useful to import C functions calls from Bee. These rules could be wrapped in Bee modules. We have not yet establish this is the way to go. If it is, we add a dependency toward C and I don't particularly like it. Yet if we implement this it should look maybe like this:</p>

<p><b>Example:</b>&nbsp;This is myLib.bee file:</p>
<pre><code class="language-bee">#module myLib
use $bee.lib.cpp.myLib; -- load cpp library
** define a wrapper for external "fib"
rule fib(n &isin; Z) =&gt; (x &isin; Z));
  let x := myLib.fib(n);
return;
</code></pre>

<p>This is the main module:</p>
<pre><code class="language-bee"># module main
** load library
use $bee.lib.myLib as myLib;
** use external rule
rule main:
  print myLib.fib(5);
return;
</code></pre>

<p>To understand more about interacting with other languages check this article about ABI:&nbsp;<a href="https://en.wikipedia.org/wiki/Application_binary_interface" rel="nofollow">Application Binary Interface</a></p>

<hr>

<h3><a id="purity-level">Rule purity level</h3>

<p>Bee compiler should track rule purity level to be able to optimize the generated code. A pure rule can be optimized better than an impure rule. Therefore a developer must understand how to create code using pure rules and avoid dirty rules as much as possible.</p>

<h4>Pure rules:</h4>

<p>Compiler can detect if a rule is pure.</p>
<p>A rule is pure when ...</p>
<ul>
<li>do not have multiple results but one;</li>
<li>do not modify external states;</li>
<li>do not perform unsafe data conversions;</li>
<li>do not raise errors;</li>
<li>do not have side-effects;</li>
<li>do not have internal rules;</li>
<li>do not accept rules as parameters;</li>
<li>do not call a dirty rule;</li>
</ul>

<h4>Dirty rules:</h4>

<p>A rule is pure as long as compiler do not degrade the rule to dirty status. A dirty rule has restrictions.</p>

<h4>Notes:</h4>
<ul>
<li>Pure rules are deterministic in contrast to stochastic rules,</li>
<li>If a rule is not pure is <em>downgraded</em> by the compiler,</li>
<li>Dirty rules can be used in assignments but not in &lambda; expressions,</li>
<li>Dirty rules can not be send as arguments to other rules for call-back,</li>
</ul>

<p><b>Read next:</b>
<a href="objects.html">Objects</a></p>

<!-- Footer -->
<footer class="footer">
  <div class="footer-copyright text-center"></div>
</footer>
</div>
</body>
</html>